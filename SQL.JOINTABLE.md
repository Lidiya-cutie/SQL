# Соединение таблиц

В этом модуле мы будем работать с таблицами о футбольных матчах и командах.

Таблицы этого модуля лежат в схеме sql или csv в папке data. Нам понадобятся таблицы teams и matches.

### Таблица **teams** с данными о командах

* __id__ - id команды
* __api_id__ - ключ на таблицу matches
* __long_name__ - полное название команды
* __short_name__ - сокращённое название команды

### Таблица **matches** с данными о матчах

* __id__ - id матча
* __season__ - сезон
* __date__ - дата матча
* __home_team_api_id__ - api_id домашней команды, ключ на таблицу teams
* __away_team_api_id__ - api_id гостевой команды, ключ на таблицу teams
* __home_team_goals__ - количество голов домашней команды
* __away_team_goals__ - количество голов гостевой команды

Узнаем количество различных полных названий команд в таблице **teams**:
```sql
SELECT 
COUNT(DISTINCT long_name)
FROM sql.teams
```
Узнаем количество в таблице **teams** команд с коротким названием VAL
```sql
SELECT 
COUNT(short_name)
FROM sql.teams
WHERE short_name = 'VAL'
```
Узнаем информацию о скольких матчах содержит таблица **matches** 
```sql
SELECT 
COUNT(*)
FROM sql.matches
```
Узнаем данные за какие сезоны даны в таблице **matches** 
```sql
SELECT 
season
FROM sql.matches
GROUP BY season
ORDER BY season
```
Напишем запрос, который выведет сезон (season), а также общее количество забитых мячей домашними (total_home_goals) и гостевыми (total_away_goals) командами.

Отсортируем по столбцу с сезоном в порядке возрастания.

```sql
SELECT 
season,
sum(home_team_goals) total_home_goals,
sum(away_team_goals) total_away_goals
FROM sql.matches
GROUP BY season
ORDER BY season
```
# ОБЪЕДИНЯЕМ ТАБЛИЦЫ БЕЗ ОПЕРАТОРОВ

Чтобы соединить две таблицы между собой, достаточно записать названия таблиц через запятую в разделе **from**. Что произойдёт в таком случае?

```sql
SELECT * /*выбор всех полей*/
FROM
    sql.teams, /*таблица с командами*/
    sql.matches /*таблица с матчами*/
```
Каждая запись, которая есть в таблице *teams*, будет соединена с каждой записью в таблице *matches*.
Это действие также называют **декартовым произведением таблиц**.

Напишем запрос, который выведет количество строк соединённой таблицы.
```sql
SELECT 
    COUNT(*) /*количество строк*/
FROM
    sql.teams, /*таблица с командами*/
    sql.matches /*таблица с матчами*/
```
В данном случае соединение таблиц не даёт практической пользы: мы получили очень много записей, которые никак не можем интерпретировать, потому что команды не соответствуют матчам.

Давайте исправим это. В таблице *teams* есть столбец **api_id**, а таблица *matches* содержит столбцы **home_team_api_id** и **away_team_api_id** — это ключи таблиц, по которым они соединяются.

**Ключ** — это поле (столбец) в таблице, которое позволяет однозначно идентифицировать запись (строку).

Чтобы соединить таблицы и получить данные о домашней команде по каждому матчу, добавим условие
**where home_team_api_id = api_id**.

```SQL
SELECT * /*выбор всех полей в таблице*/
FROM
    sql.teams, /*таблица с командами*/
    sql.matches /*таблица с матчами*/
WHERE home_team_api_id = api_id /*условие: home_team_api_id таблицы matches равен api_id таблицы teams*/
```
Аналогично можем получить данные о гостевых командах: необходимо изменить условие на
**where away_team_api_id = api_id**.
```sql
SELECT * /*выбор всех полей в таблицы*/
FROM
    sql.teams, /*таблица с командами*/
    sql.matches /*таблица с матчами*/
WHERE away_team_api_id = api_id /*условие: away_team_api_id таблицы matches равен api_id таблицы teams*/
```
Итак, мы только что объединили таблицы по **ключу**.

**Ключи бывают двух основных типов**:

1. *Primary* — **первичный ключ** — служит для идентификации текущей таблицы и, как правило, идёт первым в списке столбцов. Всегда уникален: повторяющихся значений в основной таблице быть не может.
2. *Foreign* — **внешний ключ** — представляет собой ссылку на другую таблицу.

Как правило, названия ключей имеют «хвост», который позволяет их идентифицировать: например, *_id, _rk, _cd, _pk (от primary_key), _fk (от foreign_key)* и другие.

**Обратите внимание!** В данном датасете ключ *api_id* таблицы *teams* может быть использован в разных значениях. Его можно использовать для того, чтобы получить информацию о домашней (*home*) или гостевой (*away*) команде.

С помощью известного нам запроса получим названия команд, игравших домашние матчи, и счёт матчей.
```sql
SELECT 
    long_name, /*столбец long_name таблицы teams*/
    home_team_goals, /*столбец home_team_goals таблицы matches*/
    away_team_goals /*столбец away_team_goals таблицы matches*/
FROM
    sql.teams, /*таблица с командами*/
    sql.matches /*таблица с матчами*/
WHERE home_team_api_id = api_id /*условие: home_team_api_id таблицы matches равен api_id таблицы teams*/
```
Напишем запрос, который выведет таблицу с результатами матчей для гостевых команд, содержащую:

названия гостевых команд (long_name),
количество забитых мячей домашней команды (home_team_goals),
количество забитых мячей гостевой команды (away_team_goals).

```sql
SELECT 
    long_name, /*столбец long_name таблицы teams*/
    home_team_goals, /*столбец home_team_goals таблицы matches*/
    away_team_goals /*столбец away_team_goals таблицы matches*/
FROM 
    sql.teams, /*таблица с командами*/
    sql.matches /*таблица с матчами*/
WHERE away_team_api_id = api_id /*условие: away_team_api_idтаблицы matches равен api_id таблицы teams*/
```
# JOIN

**JOIN** — это оператор *SQL*, который позволяет соединять таблицы по условию. Используем предыдущие запросы и запишем их с использованием **JOIN**

```sql
SELECT
    long_name,
    home_team_goals,
    away_team_goals
FROM
    sql.teams
JOIN sql.matches ON home_team_api_id = api_id
```

```sql
SELECT 
    long_name,
    home_team_goals,
    away_team_goals
FROM 
    sql.teams
JOIN sql.matches ON away_team_api_id = api_id
```

# СИНТАКСИС

Оператор **JOIN** упрощает процесс соединения таблиц.

Его синтаксис можно представить следующим образом:
```sql
SELECT
        столбец1,
	столбец2,
	...
FROM
	таблица1
JOIN таблица2 ON условие
```
Порядок присоединения таблиц в **данном случае** не важен — результат будет одинаковым.

С помощью JOIN можно соединить и более двух таблиц.
```sql
SELECT
        столбец1,
	столбец2,
	...
FROM
	таблица1
JOIN таблица2 ON условие
JOIN таблица3 ON условие
```
В таблицах, которые мы соединяем, могут быть одинаковые названия столбцов.

→ К примеру, столбец *id* есть и в таблице *matches*, и в таблице *teams*. Такой запрос не будет обработан.

Для этого нужно обязательно указать, откуда мы хотим запросить данные, записав название таблицы перед столбцом через точку.
```sql
SELECT
    teams.id /*столбец id таблицы teams*/
FROM 
    sql.teams /*таблица teams*/
JOIN sql.matches ON home_team_api_id = api_id /*оператор соединения таблиц; таблица matches; условие: home_team_api_id таблицы matches равен api_id таблицы teams*/
```
Зачастую названия таблиц слишком длинные, так что использовать их неудобно. Упростить обращение к различным таблицам можно, присвоив им сокращённые названия — **алиасы** (от англ. *alias*).

Синтаксис для указания алиаса такой же, как и для названия столбца.
```sql
SELECT
        столбец1,
	столбец2,
	...
FROM
	таблица1 AS короткое_название_1
JOIN таблица2 AS короткое_название_2 ON условие
```
Если необходимо записать название, в котором используются пробелы ("table 1"), то алиас можно обернуть в кавычки.

Важно! Обращаться по такому алиасу придётся также с помощью кавычек.
```sql
SELECT
    "table 1".столбец1,
    "table 2".столбец2,
    ...
FROM
    таблица1 AS "table 1"
    JOIN таблица2 AS "table 2" ON условие
```
* __->__ Использование таких алиасов считается плохой практикой как минимум по причине того, что обращаться с такими алиасами неудобно.

Вместо алиасов с кавычками рекомендуется давать простое короткое название на латинице, без специальных символов и пробелов. Если таблиц немного и все названия начинаются с разных букв, можно присваивать алиасы по первой букве.

Ключевое слово as, как и в названии столбца, можно опустить в большинстве СУБД.
```sql
SELECT
        столбец1 новое_название_столбца,
    столбец2 новое_название_столбца,
    ...
FROM
    таблица1 короткое_название_1
JOIN таблица2 короткое_название_2 ON условие
```
Напишем запрос, который выведет два столбца: id матча (match_id) и id домашней команды (team_id). Отсортируйте по id матча в порядке возрастания значений.
```sql
SELECT 
    m.id match_id,
    t.id team_id
FROM 
    sql.teams AS t
JOIN sql.matches AS m on home_team_api_id = api_id
ORDER BY match_id
```
Кажется, теперь мы можем соединить таблицы между собой и создать своё табло со счётом матчей, как на спортивных сайтах!

Давайте с помощью запроса SQL получим таблицу, содержащую:

* название домашней команды;
* количество забитых домашней командой голов;
* количество забитых гостевой командой голов;
* название гостевой команды.
```sql
SELECT
    h.long_name "домашняя команда", /*столбец long_name таблицы h*/
    m.home_team_goals "голы домашней команды", /*столбец home_team_goals таблицы m*/
    m.away_team_goals "голы гостевой команды", /*столбец away_team_goals таблицы m*/
    a.long_name "гостевая команда" /*столбец long_name таблицы a*/
FROM
    sql.matches m /*таблица matches с алиасом m*/
    JOIN sql.teams h ON m.home_team_api_id = h.api_id /*оператор соединения таблиц; таблица teams с алиасом h; условие: home_team_api_id таблицы m равен api_id таблицы h*/
    JOIN sql.teams a ON m.away_team_api_id = a.api_id /*оператор соединения таблиц; таблица teams с алиасом a; условие: away_team_api_id таблицы m равен api_id таблицы a*/
```
Напишем запрос, который выведет столбцы:

*  id матча,
*  короткое название домашней команды (home_short),
*  короткое название гостевой команды (away_short).

Отсортируйте запрос по возрастанию id матча.
```sql
SELECT
    m.id,
    h.short_name home_short,
    a.short_name away_short  
FROM
    sql.matches m
    JOIN sql.teams h ON m.home_team_api_id = h.api_id
    JOIN sql.teams a ON m.away_team_api_id = a.api_id
ORDER BY h.id
```
# РАБОТА С ОБЪЕДИНЁННЫМИ ТАБЛИЦАМИ

Напишем запрос, который выведет *id* матчей, в которых команда Arsenal была гостевой.
```sql
SELECT 
    m.id /*столбец id таблицы m*/
FROM
    sql.teams t /*таблица teams с алиасом t*/
    JOIN sql.matches m ON m.away_team_api_id = t.api_id /*оператор соединения таблиц; таблица matches с алиасом m; условие: away_team_api_id таблицы m равен api_id таблицы t*/
WHERE long_name = 'Arsenal' /*long_name таблицы teams имеет значение Arsenal*/
```
Принципиальное отличие фильтрации данных по соединённым таблицам от аналогичного действия по одиночным таблицам заключается в том, что, фильтруя записи одной таблицы, мы также будем фильтровать и записи другой таблицы, поскольку соединённые на уровне запроса таблицы по сути являются единой таблицей.

Например, результат запроса
```sql
SELECT 
	m.id id_1,
	m.season,
	t.id id_2,
	t.long_name
FROM
	sql.teams t
JOIN sql.matches m ON m.away_team_api_id = t.api_id
```
можно разделить на две разные части

Одна часть — таблица *matches* с алиасом m, вторая — *teams* с алиасом t, но после соединения они являются одной таблицей.

Таким образом, если вы отфильтруете данные по одной части таблицы, то другая, соединённая, часть пропадёт вместе с ней.

Напишем запрос, который выведет команды с коротким названием *GEN* сезона 2008/2009
```sql
SELECT * /*выбор всех полей*/
FROM    
    sql.matches m /*таблица matches с алиасом m*/
    JOIN sql.teams t on t.api_id = m.home_team_api_id /*оператор соединения таблиц; таблица teams с алиасом t; условие: home_team_api_id таблицы m равен api_id таблицы t*/
WHERE
    t.short_name = 'GEN' /*столбец short_name таблицы t имеет значение GEN*/
    AND m.season = '2008/2009' /*столбец season таблицы m имеет значение 2008/2009*/
```
## АГРЕГАЦИЯ ДАННЫХ
Нам и здесь доступны агрегатные функции.

Напишем запрос, который выведет сумму голов по тем матчам, где команда выступала в гостях
```sql
SELECT
    t.long_name, /*столбец long_name таблицы t*/
    SUM(m.home_team_goals) + SUM(m.away_team_goals) match_goals /*функция суммирования; столбец home_team_goals таблицы m; функция суммирования; столбец away_team_goals таблицы m; новое название столбца*/
FROM
    sql.matches m /*таблица matches с алиасом m*/
    JOIN sql.teams t ON m.away_team_api_id = t.api_id /*оператор соединения таблиц; таблица teams с алиасом t; условие: away_team_api_id таблицы m равен api_id таблицы t*/
GROUP BY t.id /*группировка по столбцу id таблицы t*/
```
Напишем запрос, который выведет общее количество голов по сезонам
```sql
SELECT
    m.season,
    SUM(m.home_team_goals) + SUM(m.away_team_goals) total_goals 
FROM
    sql.matches m
GROUP BY m.season
```
Напишем запрос, который выведет таблицу суммарно забитых голов в матчах по командам и сезонам для команд, у которых суммарное количество голов в сезонах больше 100 

```SQL
SELECT
    m.season,
    t.long_name,
    SUM(m.home_team_goals) + SUM(m.away_team_goals) total_goals 
FROM
    sql.matches m
    JOIN sql.teams t ON t.api_id = m.home_team_api_id OR t.api_id = m.away_team_api_id
GROUP BY m.season, t.id
HAVING SUM(m.home_team_goals) + SUM(m.away_team_goals) > 100
```
Напишем запрос, который выведет полное название команды (long_name), количество голов домашней команды (home_goal) и количество голов гостевой команды (away_goal) в матчах, где домашней командой были команды с коротким названием 'GEN'. Отсортируем запрос по id матча в порядке возрастания.
```SQL
SELECT
    t.long_name long_name,
    m.home_team_goals home_goal,
    m.away_team_goals away_goal 
FROM
    sql.matches m
    JOIN sql.teams t ON t.api_id = m.home_team_api_id 
WHERE t.short_name = 'GEN'
ORDER BY m.id
```
Напишем запрос, чтобы вывести id матчей, короткое название домашней команды (home_short), короткое название гостевой команды (away_short) для матчей сезона 2011/2012, в которых участвовала команда с названием Liverpool. Отсортируем по id матча в порядке возрастания.
```sql
SELECT
    m.id id,
    h.short_name home_short,
    a.short_name away_short
FROM
    sql.matches m
    JOIN sql.teams h ON m.home_team_api_id = h.api_id
    JOIN sql.teams a ON m.away_team_api_id = a.api_id
WHERE season = '2011/2012' AND (h.long_name = 'Liverpool' or a.long_name = 'Liverpool')
ORDER BY m.id
```
Напишем запрос, с помощью которого можно вывести список полных названий команд, сыгравших в гостях 150 и более матчей. Отсортируем список по названию команды.

```sql
SELECT
    t.long_name
FROM
    sql.matches m
    JOIN sql.teams t ON m.away_team_api_id = t.api_id
GROUP BY t.id
HAVING COUNT(*) >= 150
ORDER BY t.long_name
```
