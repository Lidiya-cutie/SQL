# ЧТО ТАКОЕ БАЗЫ ДАННЫХ?

**База данных** — это организованная структура для хранения, изменения и обработки взаимосвязанной информации.

# ВИДЫ БАЗ ДАННЫХ

Базы данных можно разделить на два вида:

* __Реляционные__. В таких БД данные хранятся в виде связанных таблиц. В этом курсе мы сфокусируемся именно на реляционных БД.
* __Нереляционные__. Такие БД имеют специфическую структуру: например, данные хранятся в формате ключ-значение или в виде дерева.

Подробнее о видах баз данных можно прочитать [здесь](https://tproger.ru/translations/sql-nosql-database-models/).

# ХРАНЕНИЕ ДАННЫХ В БД

Данные в реляционных БД хранятся в виде **таблиц**. Каждая таблица обычно содержит данные, относящиеся к похожим объектам. У каждой таблицы есть название: оно соотносится с тем, какая информация хранится в таблице.

Таблицы в БД состоят из **строк** и **столбцов**. Каждый столбец имеет своё уникальное название, которое также отмечает вид хранимой в нём информации. В каждой строке хранится информация об одном объекте.

**Обратите внимание!** Для связи данных в разных таблицах часто используют **ID** — уникальный идентификатор какой-либо строки. Имя или какой-либо признак с этой целью не используются, поскольку они могут быть неуникальными.

# СИСТЕМЫ УПРАВЛЕНИЯ БАЗАМИ ДАННЫХ

**Система управления базами данных**, или **СУБД** (от англ. *DataBase Management System, DBMS*) — это комплекс программных средств, необходимых для создания структуры новой базы, её наполнения, редактирования содержимого и отображения информации.

Существует множество СУБД, наиболее распространённые из них — *MySQL, PostgreSQL, Oracle, Microsoft SQL Server*. Для очень большого объёма данных также используют *ClickHouse, Hadoop* и др.

Для работы с данными, хранящимися в БД, используется специальный язык — **SQL**, который мы и будем изучать. Для работы с разными СУБД используются разные диалекты *SQL*.

**SQL-запрос** представляет собой совокупность операторов, инструкций, вычисляемых функций.

# ВИДЫ ОПЕРАТОРОВ SQL

## Операторы SQL делятся на:

*  __операторы определения данных (Data Definition Language, DDL)__ — с их помощью создаются и изменяются объекты в БД (сама БД, таблицы, функции, процедуры, пользователи и т. д.);
*  __операторы манипуляции данными (Data Manipulation Language, DML)__ — с их помощью проводятся манипуляции с данными в таблицах;
*  __операторы определения доступа к данным (Data Control Language, DCL)__ — с их помощью, как следует из названия, создаются и изменяются разрешения на определённые операции с объектами в БД;
*  __операторы управления транзакциями (Transaction Control Language, TCL)__ — с их помощью осуществляется комплекс определённых действий, причём так, что либо все эти действия выполняются успешно, либо ни одно из них не выполняется вообще.

Для написания запросов к БД необходим специальный инструмент. 

**Metabase** — это бесплатный и удобный инструмент для первичного анализа данных с возможностью передавать запросы.

Например, имеем таблицу kinopoisk, где  хранятся следующие данные:
* position	-  номер в базе данных
* movie_title  -  название фильма
* year	-  год выпуска
* country	-  страна выпуска
* rating	-  рейтинг фильма в базе
* overview	-  описание фильма

```sql
SELECT *
FROM sql.kinopoisk
```
РАЗБИРАЕМ ЗАПРОС

→ Оператор SELECT сообщает СУБД, что вы хотите извлечь из неё данные. SELECT лежит в основе любого SQL-запроса к БД.

→ FROM sql.kinopoisk сообщает, из какой таблицы извлекаются данные. Сначала указывается название схемы, в которой содержится таблица (в нашем случае — это sql), а после точки — название самой таблицы (kinopoisk).

→ Звёздочка * указывает, что вы хотите видеть все столбцы этой таблицы.

Напишем запрос, который выведет из таблицы kinopoisk столбцы с названием фильма, годом его выпуска и рейтингом.
```sql
SELECT 
    movie_title, 
    year, 
    rating
FROM sql.kinopoisk
```
Запрос, аналогичный запросу выше, только вместо года выхода фильма, вам нужен его «возраст» на 2020 год.

```sql
SELECT /*выбор столбцов*/
    movie_title, /*столбец movie_title*/
    2020 - year, /*столбец, каждое из значений которого ровно разнице 2020 и соответствующего значения столбца year*/
    rating /*столбец rating*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
```
Напишем запрос, который выведет из таблицы kinopoisk следующие столбцы:

* имя режиссёра (director),
* название фильма (movie_title),
* разница между максимально возможным рейтингом (10) и рейтингом этого фильма.

```sql
SELECT /*выбор столбцов*/
    director, /*столбец director*/
    movie_title, /*столбец movie_title*/
    10 - rating /*столбец, значения в котором равны разнице 10 и каждого соответствующего значения столбца rating*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
```
Давайте наведём порядок и переименуем столбец!
```sql
SELECT /*выбрать столбцы*/
    director, /*столбец director*/
    movie_title, /*столбец movie_title*/
    10 - rating AS difference /*столбец, значения в котором равны разнице 10 и каждого соответствующего значения столбца rating; присвоить столбцу алиас difference*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
```
Новое имя является просто псевдонимом, или алиасом, — оно временное и не меняет реального имени столбца в базе данных. **Алиас** влияет только на то, как столбец отображается в выводе конкретного запроса.

Обратите внимание! Если в алиасе используются пробелы, необходимо заключать весь псевдоним в двойные кавычки, например, *movie_title AS "Movie Title"*.

# ПРОСТЫЕ ОПЕРАЦИИ С ДАННЫМИ
Со столбцами, которые содержат числовые данные, можно проводить арифметические операции:

*  сложение с помощью + ;
*  вычитание с помощью - (этот тип операции вы уже проводили, когда определяли «возраст» фильма);
*  умножение с помощью * ;
*  деление с помощью / ;
   * __Важно!__ Если и числитель, и знаменатель — целые числа, результат деления также будет целочисленным, то есть этот оператор произведёт деление нацело.
*  получение остатка от деления с помощью % .

С полным перечнем доступных арифметических операций вы можете ознакомиться в [официальной документации](https://postgrespro.ru/docs/postgresql/11/functions-math).

```sql
SELECT /*выбрать столбцы*/
    director, /*столбец director*/
    movie_title, /*столбец movie_title*/
    rating * 10 AS rating_100
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
```
Давайте выведем для каждого фильма результат деления года его выпуска на рейтинг 
```sql
SELECT /*выбрать столбцы*/
    movie_title, /*столбец movie_title*/
    year / rating /*столбец, значения которого равны результату деления значений столбца year на соответствующие значения столбца rating*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
```
## WHERE
Eсли мы хотим видеть не все строки, а только некоторые из них, тогда нам пригодится ключевое слово **WHERE**.
```sql
SELECT * /*выбор всех столбцов*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
WHERE position = 1 /*с позицией 1*/
```

Напишем запрос, чтобы вывести все столбцы для фильмов, которые вышли в прокат в 1999 году.
```sql
SELECT * /*выбор всех столбцов*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
WHERE year = 1999 /* С 1999 годом */
```

Посмотрим на фильмы, которые вышли в прокат до 1984 года.
```sql
SELECT 
    position, /*выбор столбцa position*/
    movie_title, /*выбор всех столбцa movie_title*/
    year, /*выбор всех столбцa year*/
    director /*выбор всех столбцa director*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
WHERE year < 1984 /*С годом ранее 1984*/
```
Выведем все столбцы для всех фильмов, кроме тех, что были сняты в 2000 году.

```sql
SELECT * /*выбор всех полей*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
WHERE year <> 2000 /*если год создания не 2000*/
```
# AND И OR
Мы хотим, чтобы фильм был относительно современным и с высоким рейтингом.

```sql
SELECT * /*выбор всех полей*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
WHERE year >= 2000 /*при условии, что год создания больше или равен 2000*/
AND rating >= 8 /*и с рейтингом от 8 и выше*/
```
Теперь вы хотите получить информацию о фильмах, которые вышли между 1975 и 1985 годами включительно. Можно воспользоваться следующим запросом:
```sql
SELECT * /*выбор всех полей*/
FROM sql.kinopoisk /*из таблицы sqk.kinopoisk*/
WHERE year >= 1975 /*при условии, что год создания 1975 и позднее*/
    AND year <= 1985 /*и ранее 1985*/
```
# BETWEEN

Мы только что отправили запрос для вывода данных по фильмам с 1975 и 1985 годы. Цели мы достигли, но сама запись оставляет желать лучшего.

Можем оптимизировать её, сделав более элегантной с помощью BETWEEN:

```sql
SELECT * /*выбор всех полей*/
FROM sql.kinopoisk /*из таблиц sql.kinopoisk*/
WHERE year BETWEEN 1975 AND 1985 /*при условии, что год создания лежит в промежутке между 1975 и 1985*/
```

Напишите запрос, который выведет столбцы с именем режиссёра и названием фильмов, у которых рейтинг больше или равен 8.5.
```sql
SELECT
    director,
    movie_title
FROM sql.kinopoisk
WHERE rating >= 8.5
```
# NOT
Выведем все фильмы, кроме тех, что вышли с 1965 по 1980 годы.

```sql
SELECT * /*выбор всех полей*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
WHERE year NOT BETWEEN 1965 AND 1980 /*при условии, что год создания не лежит в промежутке между 1965 и 1980*/
```
Если включаете в запрос несколько условий **AND** и **OR**, используйте скобки: они работают так же, как и с арифметическими операциями.

Важно! Условия в скобках имеют больший приоритет.
```sql
SELECT /*выбор*/
    year, /*столбец year*/
    movie_title, /*столбец movie_title*/
    director /*столбец director*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
WHERE (rating > 8.5 AND year < 2000) /*при условии, что рейтинг больше 8.5 и год создания до 2000*/
    OR year >= 2000 /*или год создания — 2000 и позднее*/
```
# IN
Ещё один полезный оператор для фильтрации строк — IN.

Конструкции с IN имеют следующий вид:
```sql
column IN (value1, value2, value3)
```
Напишите запрос, который выводит названия фильмов, вышедших в прокат в 2000, 1985 и 1939 годах.
```sql
SELECT movie_title
FROM sql.kinopoisk
WHERE year IN (2000, 1985, 1939)
```
# LIKE
Предположим, мы не знаем точно, какое текстовое значение ищем.

В таком случае нам поможет оператор *LIKE*.

Hапример, чтобы получить все фильмы, название которых начинается на А (кириллическую), мы воспользуемся таким запросом:
```sql
SELECT * /*выбор всех полей*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
WHERE movie_title LIKE 'А%' /*если название фильма начинается на А*/
```
Знак процента (%) в примере показывает, что после A встречается ноль и более символов. Вы можете использовать % в любом месте внутри строки.

Например, **movie_title LIKE '%а%б%'** выведет все фильмы, в названии которых встречается строчная буква а, а где-то после неё — б.

Также в текстовых строках используется знак подчёркивания (_) — он заменяет ровно один любой символ.

Напишите запрос, чтобы вывести название и год выпуска в прокат тех фильмов, которые были сняты режиссёром по имени Дэвид (то есть значение в поле director начинается с 'Дэвид') и имеют рейтинг больше 8.
```sql
SELECT 
    movie_title, 
    year
FROM sql.kinopoisk
WHERE director LIKE 'Дэвид%'
    AND rating > 8.0
```
# NULL
Вернёмся к просмотру всей таблицы с ТОП-250.
Вы можете заметить, что у некоторых строк заполнены не все столбцы.

Для пустых значений есть специальное обозначение — *NULL*.

**Важно!** *NULL* — это специальное значение. Если вы фильтруете столбец, в котором есть пустые значения, по любому условию, кроме *IS NULL* / *IS NOT NULL*, такие значения будут исключены из вывода.
# ORDER BY
Чтобы задать порядок вывода строк в запросе, применим новое ключевое слово ORDER BY. Для примера отсортируем фильмы по их названию в алфавитном порядке.
```sql
SELECT *
FROM sql.kinopoisk
ORDER BY movie_title
```
Напишите запрос, который выведет из таблицы kinopoisk все столбцы и отсортируйте строки по возрастанию рейтинга фильма.
```sql
SELECT *
FROM sql.kinopoisk
ORDER BY rating
```
Наш запрос с сортировкой по названию аналогичен такому:
```sql
SELECT *
FROM sql.kinopoisk
ORDER BY rating ASC
```
Здесь *ASC* — явное указание порядка сортировки по возрастанию (англ. *ascending*).

Для обратного порядка используется ключевое слово *DESC* (англ. *descending*).

Разумеется, мы можем комбинировать в нашем запросе фильтрацию строк и сортировку вывода, а также выводить только необходимые столбцы.

Выведем названия, имена режиссёров и сценаристов, а также год выхода в прокат фильмов, выпущенных в СССР, и отсортируем результат по убыванию рейтинга.
```sql
SELECT /*выбор*/
    movie_title, /*столбец movie_title*/
    director, /*столбец director*/
    screenwriter, /*столбец screenwriter*/
    year /*столбец year*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
WHERE country = 'СССР' /*при условии, что страна производства — СССР*/
ORDER BY rating DESC /*сортировка по рейтингу в порядке убывания*/
```
**Обратите внимание!** Ключевое слово *ORDER BY* идёт после применения всех условий в *WHERE*.

Напишите запрос, который выведет столбцы с названием фильма, его описанием и годом выхода в прокат. Оставьте только те фильмы, у которых рейтинг не ниже 8.2 и страна производства — не США. Отсортируйте вывод по году выхода фильма в порядке убывания.
```sql
SELECT
    movie_title,
    overview,
    year
FROM sql.kinopoisk
WHERE country != 'США'
    AND rating >= 8.2
ORDER BY year DESC
```
Или так 
```sql
SELECT 
    movie_title, 
    overview, 
    year
FROM sql.kinopoisk
WHERE rating >= 8.2 
    AND country NOT IN ('США')
ORDER BY year DESC
```
Также в ORDER BY можно указывать, где должны идти пустые значения — в начале или в конце.

Такая настройка порядка вывода задаётся с помощью ключевых слов *NULLS FIRST* / *NULLS LAST*.
```sql
SELECT  /*выбор*/
    movie_title,  /*столбец movie_table*/
    rating,  /*столбец rating*/
    overview,  /*столбец overview*/
    year /*столбец year*/
FROM sql.kinopoisk  /*из таблицы sql.kinopoisk*/
ORDER BY overview /*сортировка по столбцу overview*/
```
А теперь измените последнюю строку скрипта на *ORDER BY overview NULLS FIRST*.

Такой запрос выведет первыми строки с пустым описанием.

Вы можете сортировать вывод по нескольким столбцам, просто указав их через запятую в ORDER BY (порядок сортировки указывается отдельно для каждого столбца).

Кроме того, вы можете сортировать результат запроса и по тем столбцам, которых нет в выводе.

Получили список всех режиссёров и фильмов из ТОП-250, отсортированных по году выхода в прокат, а внутри года — по рейтингу в порядке убывания.

```sql
SELECT /*выбор*/
    director, /*столбец director*/
    movie_title /*столбец movie_title*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
ORDER BY year, rating DESC /*сортировка по столбцам year и rating в порядке убывания*/
```

Напишите запрос, чтобы вывести названия всех фильмов (столбец Название фильма), у которых рейтинг выше 8.3 и страна производства — Франция. Отсортируйте по рейтингу в порядке убывания, далее — по году выхода в прокат (также в порядке убывания).
```sql
SELECT
    movie_title AS "Название фильма"
FROM sql.kinopoisk
WHERE rating > 8.3
    AND country = 'Франция'
ORDER BY rating DESC, year DESC
```
Или так
```sql
SELECT 
    movie_title
FROM sql.kinopoisk
WHERE rating > 8.3 
    AND country IN ('Франция')
ORDER BY rating DESC, year DESC
```
Для упрощения работы с ORDER BY можно использовать не названия столбцов, а их номера из вывода
```sql
SELECT /*выбор*/
    director, /*столбец director*/
    movie_title, /*столбец movie_title*/
    year /*столбец year*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
ORDER BY 1, 3 DESC /*сортировка по первому и третьему столбцам*/
```
Сортировку по номеру столбца стоит использовать с осторожностью, поскольку при изменении вывода в *SELECT* всё может сбиться.

При добавлении новых столбцов в *SELECT* нужно проверить и при необходимости поправить номера столбцов в *ORDER BY*.
# LIMIT
По умолчанию при любом запросе вы получаете в выводе все строки, попадающие под условия запроса.

Чаще всего именно этого вы и ожидаете, но иногда, например, вам нужно просто взглянуть на содержание таблицы, при этом чем она она больше, тем дольше будет работать запрос.

Ограничим вывод первыми десятью строками и сможем легко понять, какие данные хранятся в таблице, не утяжеляя результат.

```sql
SELECT * /*выбор всех полей*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
LIMIT 10 /*ограничить вывод десятью значениями*/
```
Ещё один типичный случай использования ограничения вывода — вывод ТОПа по какому-то показателю.

Выведем ТОП-5 фильмов по рейтингу, сначала отсортировав их по убыванию, а потом оставив только верхние пять строк с помощью LIMIT.

```sql
SELECT /*выбор*/
    movie_title, /*столбец movie_title*/
    rating /*столбец rating*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
ORDER BY rating DESC /*сортировка по столбцу rating в порядке убывания*/
LIMIT 5 /*ограничить пятью значениями*/
```
**Обратите внимание!** Ключевое слово *LIMIT* используется в самом конце запроса.

Напишите запрос, который выводит информацию (Режиссёр, Название фильма и Актёры) по ТОП-20 самых старых (определяем по году выхода в прокат) фильмов из таблицы kinopoisk.

Выведите столбцы Режиссёр, Название фильма, Актёры.
```sql
SELECT
    director "Режиссёр",
    movie_title "Название фильма",
    actors "Актёры"
FROM sql.kinopoisk 
ORDER BY year
LIMIT 20
```
# OFFSET
Если *LIMIT* «оставляет» указанное число первых строк из вывода, то *OFFSET*, наоборот, «обрезает» указанное число первых строк.

*LIMIT* и *OFFSET* можно использовать вместе, их порядок не важен.

Выведем название и рейтинг фильмов с четвёртого по восьмое место.
```sql
SELECT /*выбор*/
    movie_title, /*столбец movie_title*/
    rating /*столбец rating*/
FROM sql.kinopoisk /*из таблицы sql.kinopoisk*/
ORDER BY rating DESC /*сортировка по столбцу rating в порядке убывания*/
OFFSET 3 LIMIT 5 /*исключить первые три строки и вывести пять следующих за ними*/
```
Таким образом, *LIMIT* отсчитывает количество строк после указанной в *OFFSET* строки.

Напишите запрос, чтобы вывести названия фильмов, которые вышли в прокат после 1990 года и были сняты не в России. Из этого списка оставьте только те фильмы, которые занимают с 20 по 47 места в рейтинге. Отсортируйте результат по убыванию рейтинга фильмов.
```sql
SELECT
    movie_title
FROM sql.kinopoisk
WHERE year > 1990
    AND country != 'Россия'
ORDER BY rating DESC
OFFSET 19 LIMIT 28
```
Напишите запрос, который выводит столбцы «Название фильма» (movie_title), «Режиссёр» (director), «Сценарист» (screenwriter), «Актёры» (actors). Оставьте только те фильмы, у которых:

*  рейтинг между 8 и 8.5 (включительно) ИЛИ год выхода в прокат до 1990;
*  есть описание;
*  название начинается не с буквы 'Т';
*  название состоит ровно из 12 символов.
```sql
SELECT
    movie_title "Название фильма",
    director "Режиссёр",
    screenwriter "Сценарист",
    actors "Актёры"
FROM sql.kinopoisk
WHERE (rating BETWEEN 8 AND 8.5 OR year < 1990)
    AND overview IS NOT NULL
    AND movie_title NOT LIKE 'Т%'
    AND movie_title LIKE '____________'
ORDER BY rating DESC
LIMIT 7
```
