# UNION и ручная генерация

Составим запрос, который позволит вывести первые три буквы алфавита и их порядковые номера.
```sql
SELECT 
         'a' letter,'1' ordinal_position /*сами задаём значение первого столбца ‘a’ и алиас для него letter, значение второго столбца ‘1’ и алиас для него ordinal_position*/
         
UNION /*оператор присоединения*/

SELECT 
         'b','2' /*сами задаём значение первого столбца ‘b’, значение второго столбца ‘2’ */
         
UNION /*оператор присоединения*/

SELECT
         'c','3' /*сами задаём значение первого столбца ‘с’, значение второго столбца ‘3’*/ 
```

Существуют сложные алгоритмы сравнения текстовых значений, но главный смысл сводится к одному: сравнение производится на основе таблицы unicode и позиции элемента в ней с учётом определённых условий.

Напишите запрос, который выберет наибольшее из значений:

* 1000000;
* 541;
* -500;
* 100.
Столбец с результатом назовите result.

```sql
SELECT 1000000 result
UNION
SELECT 541
UNION
SELECT -500
UNION
SELECT 100
ORDER BY result DESC
LIMIT 1
```
Помним, что сортировка для числовых и строковых типов данных отличается. Построив запрос по аналогии с примером, приведите значения к текстовому типу данных, сравните и выберите наибольшее из них:

* 1000000;
* 541;
* -500;
* 100.
Столбец с ответом назовите mycol
```sql
SELECT '1000000' mycol
UNION
SELECT '541'
UNION
SELECT '-500'
UNION
SELECT '100'
ORDER BY mycol DESC
LIMIT 1
```
Построив запрос по аналогии с примером, найдите самое большое значение из перечисленных операторов:

* _+_ ;
* _-_ ;
* _=_ ;
* _/_ .

Столбец с ответом назовите result.
```sql
SELECT '+' result
UNION
SELECT '-'
UNION
SELECT '='
UNION
SELECT '/'
ORDER BY result DESC
LIMIT 1
```
# ИСКЛЮЧАЕМ ПОВТОРЯЮЩИЕСЯ ДАННЫЕ
Предположим, нам нужно узнать, в какие города осуществлялась доставка, за исключением тех, в которых проживают водители.
```sql
SELECT
         c.city_name /*выбираем столбец city_name*/
FROM
         sql.shipment s /*из схемы sql и таблицы shipment, задаём таблице алиас s*/
JOIN sql.city c ON s.city_id = c.city_id /*внутреннее присоединение из схемы sql таблицы city, задав ей алиас c, по ключам city_id*/

EXCEPT /*оператор присоединения*/

SELECT
         cc.city_name  /*выбираем столбец city_name*/
FROM
         sql.driver d /*из схемы sql и таблицы driver, задаём таблице алиас d*/
JOIN sql.city cc ON d.city_id=cc.city_id /*внутреннее присоединение из схемы sql таблицы city, задав ей алияс cc, по ключам city_id*/
ORDER BY 1 /*сортировка по первому столбцу*/
```
Все водители проживают в городе Memphis, и мы видим, что он не выводится в результате запроса.

Как вы, должно быть, заметили, для решения этой задачи мы использовали оператор *EXCEPT*. Принципы его работы мы сейчас разберём

Синтаксические правила для оператора *EXCEPT* такие же, как и для *UNION*:

* одинаковый тип данных;
* одинаковое количество столбцов;
* одинаковый порядок столбцов согласно типу данных.

Синтаксис выглядит следующим образом:
```sql
SELECT 
         n columns
FROM 
         table_1

EXCEPT

SELECT 
         n columns
FROM 
         table_2
```
Мы уже знаем, как решить такую задачу с использованием *LEFT JOIN*. Вариант с *EXCEPT* будет полезен в тех случаях, когда у вас много столбцов и вам не хочется прописывать их равенство в условии для *JOIN*.

Предположим, у нас есть информация о продажах канцелярского магазина за май и июнь.

Какие-то позиции продавались и в том, и в другом месяце, а какие-то — только в одном. Использовав EXCEPT, мы можем оставить только те товары, которые есть в первом запросе (например, за май), но отсутствуют во втором запросе (например, за июнь).

Графически действие оператора можно представить следующим образом:

Таким образом, при присоединении с помощью EXCEPT мы вывели только те товары, которые были проданы в мае, но не в июне. Чтобы найти продажи по тем позициям, что были реализованы в июне, а в мае — нет, необходимо поменять запросы местами.

Выведите список zip-кодов, которые есть в таблице sql.driver, но отсутствуют в таблице sql.customer. Отсортируйте по возрастанию, столбец к выводу — zip. 
```sql
SELECT
  d.zip_code
FROM
  sql.city c
  JOIN sql.driver d ON d.city_id = c.city_id
EXCEPT
SELECT 
  cc.zip
FROM
  sql.driver d
  JOIN sql.customer cc ON d.city_id = cc.city_id
```