# Функции и операторы для работы с датами
## ФУНКЦИЯ EXTRACT()
Функция *extract()* получает из значений даты/времени такие поля, как год или час. Функция *extract()* возвращает значения типа double precision.

**DAY**

Для значений *timestamp* это день месяца (1-31), для значений *interval* — число дней.
```sql
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40')
-- Результат: 16
```
```sql
SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute')
-- Результат: 40
```
**HOUR**
```sql
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40')
-- Результат: 20
```
**MONTH**
```sql
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40')
-- Результат: 2
```
**YEAR**

Поле года. Учтите, что года 0 не было, и это следует иметь в виду, вычитая из годов нашей эры годы до нашей эры.
```sql
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40')
-- Результат: 2001
```
**ISOYEAR**
Год по недельному календарю ISO 8601, в который попадает дата (не применимо к интервалам).
```sql
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01')
-- Результат: 2005
```
```sql
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02')
-- Результат: 2006
```
Год по недельному календарю ISO начинается с понедельника недели, в которой оказывается 4 января, так что в начале января или в конце декабря год по ISO может отличаться от года по григорианскому календарю. Подробнее об этом рассказывается в описании поля week.

**WEEK**

В системе нумерации недель ISO первые числа января могут относиться к 52-й или 53-й неделе предыдущего года, а последние числа декабря — к первой неделе следующего года.

Например, 2005-01-01 относится к 53-й неделе 2004 г., а 2006-01-01 — к 52-й неделе 2005 г., тогда как 2012-12-31 включается в первую неделю 2013 г.

Поэтому для получения согласованных результатов рекомендуется использовать поле isoyear в паре с week.
```sql
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40')
-- Результат: 7
```
**CENTURY**
```sql
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13')
-- Результат: 20
```
```sql
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40')
-- Результат: 21
```
**DECADE**

Десятилетие.
```sql
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40' 
-- Результат: 200
```
**EPOCH**
Для значений *timestamp with time zone* это число секунд с 1970-01-01 00:00:00 UTC (может быть отрицательным); для значений *date* и *timestamp* это число секунд с 1970-01-01 00:00:00 по местному времени, а для *interval* — общая длительность интервала в секундах.
```sql
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE
'2001-02-16 20:38:40.12-08')
-- Результат: 982384720.12
```
```sql
SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours')
-- Результат: 442800
```
Преобразовать время эпохи обратно, в значение дата/время, с помощью to_timestamp можно так:
```sql
SELECT to_timestamp(982384720.12)
-- Результат: 2001-02-17 04:38:40.12+00
```
**DOW**

День недели, считая с воскресенья (0) до субботы (6).
```sql
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40')
-- Результат: 5
```
Заметьте, что в *extract()* дни недели нумеруются не так, как в функции *to_char(..., 'D')*.

**DOY**

День года (1-365/366).
```sql
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40')
-- Результат: 47
```
**ISODOW**

День недели, считая с понедельника (1) до воскресенья (7).
```sql
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40')
-- Результат: 7
```
Результат отличается от dow только для воскресенья. Такая нумерация соответствует ISO 8601.

Давайте посчитаем помесячную статистику по доставкам, используя функцию extract. Напишите запрос, который выведет год, месяц и количество доставок. Отсортируйте по году и по месяцу в порядке возрастания. Столбцы в выдаче: year_n (номер года), month_n (номер месяца), qty (количество доставок).
```sql
SELECT 
    EXTRACT(YEAR FROM s.ship_date) year_n,
    EXTRACT(MONTH FROM s.ship_date) month_n,
    COUNT(*) qty
FROM shipping.shipment s
GROUP BY 1, 2
ORDER BY 1, 2
```
## ФУНКЦИЯ TO_CHAR()
Функция *to_char()* нужна для форматирования даты времени и интервалов в нужный текст. По результату работы она очень близка к extract(), но больше нацелена именно на форматирование. Ниже вы видите таблицу с примерами вызовов:

* **to_char(timestamp[date],text)** - *text* - преобразует время в текст	to_char(current_timestamp, 'HH12:MI:SS')
* **to_char(interval, text)** - *text* - преобразует интервал в текст	to_char(interval '15h 2m 12s', 'HH24:MI:SS')

Первый параметр для функции — дата, время или интервал, а второй — текстовая маска получаемого результата. Перечень значений, которые можно использовать для маски, представлен в таблице ниже.

* **HH24**	час (00-23)
* **MI**	минута (00-59)
* **SS**	секунда (00-59)
* **MS**	миллисекунда (000-999)
* **SSSS**	число секунд с начала суток (0-86399)
* **YYYY**	год (4 или более цифр)
* **YY**	последние две цифры года
* **month**	полное название месяца в нижнем регистре (дополненное пробелами до девяти символов)
* **MM**	номер месяца (01-12)
* **day**	полное название дня недели в нижнем регистре, дополненное пробелами до девяти символов
* **DDD**	номер дня в году (001-366)
* **DD**	день месяца (01-31)
* **ID**	номер дня недели по ISO 8601, считая с понедельника (1) до воскресенья (7)
* **WW**	номер недели в году (1-53); первая неделя начинается в первый день года

Полный перечень вы можете посмотреть в [подсказке по кодам форматирования](https://postgrespro.ru/docs/postgrespro/9.5/functions-formatting)

Любой текст, который относится к кодам форматирования, будет сохранён как есть. Чтобы оставлять какие-то подсказки и использовать обычные буквы, которые не встречаются в таблице выше, необходимо заключить текст, который нужно оставить без изменений, в **двойные кавычки**.

Предположим, мы хотим вывести сегодняшнюю дату в формате **"Hello! Today is #название дня недели год.название месяца.день#"** текстом. Для этого нужно выполнить следующий код: 
```sql
SELECT to_char(now(), '"Hello! Today is" DAY yyyy-Mon-dd')
```
Давайте выведем текст текущего времени для сервиса точного времени. Напишите запрос, который выводит текст "Точное время x часов y минут z секунд" (текст в кавычки заключать не нужно), где x, y, z — часы, минуты и секунды соответственно, при условии, что сообщение нужно вывести для московского часового пояса. Время введите в 24-часовом формате. Столбцы в выдаче: msg (сообщение).
```sql
SELECT to_char(now() at time zone 'Europe/Moscow', 'Точное время HH24 часов MI минут SS секунд') msg
```
## ФУНКЦИЯ DATE_TRUNC()
Функция *date_trunc()* позволяет отсечь заданное время, дату или дату со временем до нужной точности.

Формат вызова:

 **date_trunc**('поле', значение)

 Например, если мы хотим округлить текущее время-дату до минут, то можно вызвать
 ```sql
SELECT date_trunc('minute', now())
```
Для получения разной степени точности вместо minute можно использовать следующие параметры:
* microseconds;
* milliseconds;
* second;
* minute;
* hour;
* day;
* week;
* month;
* quarter;
* year;
* decade;
* century;
* millenn

Из их названий легко понять, какая временная единица подразумевается.

Давайте подготовим данные для квартальной отчётности компании. Напишите запрос, который выведет дату доставки, округлённую до квартала, и общую массу доставок. Отсортируйте по кварталу в порядке возрастания. Столбцы в выдаче: q (начало квартала, тип date), total_weight (сумма масс доставок за квартал).
```sql
SELECT
    date_trunc('quarter', s.ship_date)::date q,
    SUM(s.weight) total_weight
FROM shipping.shipment s
GROUP BY 1
ORDER BY 1
```
## МАТЕМАТИЧЕСКИЕ ОПЕРАТОРЫ
К любой дате можно прибавить (и вычесть из неё) целое число X и получить другую дату, которая больше (меньше) изначальной.

Пример:
```sql
SELECT '2019-01-01'::date + 10
-- Результат: '2019-01-11'
```
Это — дата на 10 дней позже 2019-01-01.

При добавлении (или вычитании) целого числа к дате Postgres учитывает переходы между месяцами и годами и даёт верный ответ, соответствующий календарю. Учитываются даже високосные годы.

Пример:
```sql
SELECT '2019-01-01'::date + 500
-- Результат: '2020-05-15'
```
Как видим, сменились и год, и месяц, и день.

Аналогично можно вычесть из одной даты другую и получить расстояние в днях между этими датами. При такой операции тоже будет честная разница по календарю.

Пример:
```sql 
SELECT '2019-02-10'::date - '2017-03-01'::date
-- Результат: 711
```
Давайте оценим, в каком интервале совершались доставки в разных городах. Напишите запрос, который выведет разницу между последним и первым днём доставки по каждому городу. Отсортируйте по первому и второму столбцам. Столбцы в выдаче: city_name (название города) и days_active (время от первой до последней доставки в днях).
```sql
SELECT
    c.city_name,
    MAX(s.ship_date) - MIN(s.ship_date) as days_active
FROM shipping.shipment s
    JOIN shipping.city c ON s.city_id = c.city_id
GROUP BY 1
ORDER BY 1
```
## СОЕДИНЕНИЕ СТРОК

Для начала познакомимся с оператором конкатенации строк — || (две вертикальные черты). Он позволяет объединять две и более строки. Конструкции с оператором соединения строк записываются следующим образом:
```sql
строка1 || строка2 || ... || строкаN
```
**Важно!** Результатом соединения любых типов строковых данных будет тип text.

Напишем запрос, который позволит подготовить простые select-запросы для всех таблиц из схемы.
```sql
SELECT 'select * from
'||t.table_schema||'.'||t.table_name||';' query
FROM information_schema.tables t
WHERE table_schema = 'shipping'
```
В результате пять SQL-запросов:

-query-
* select * from shipping.truck;
* select * from shipping.city;
* select * from shipping.customer;
* select * from shipping.driver;
* select * from shipping.shipment;

**Важно!** Если вы соединяете любую строку и *NULL*, то результатом будет *NULL*. Поэтому, если вы формируете какой-то текст на основе поля, в котором присутствует *NULL*, используйте оператор *coalesce*.

Составим текстовый шаблон сообщения о доставке по конкретному водителю для наших клиентов. Напишите SQL-запрос, который выведет следующее сообщение для каждого водителя по форме:

Ваш заказ доставит водитель #Имя Фамилия#. Его контактный номер: #Номер#
Где #Имя Фамилия# и #Номер# взяты из справочника водителей. Если номер не указан, то выведите прочерк (-). Для номеров рекомендуем использовать COALESCE. Пример из таблицы для наглядности:

Ваш заказ доставит водитель Adel Al-Alawi. Его контактный номер: (901) 947-4433
Столбец к выдаче — msg (текст сообщения).
```sql
SELECT 'Ваш заказ доставит водитель '||d.first_name||' '||d.last_name||'. '||'Его контактный номер: '||coalesce(d.phone,'-') msg 
FROM shipping.driver d
```
## ФУНКЦИИ UPPER() И LOWER()
Функции *upper(your_text)* и *lower(your_text)* переводят каждый символ вашего текста в верхний и нижний регистр соответственно.

Пример:
```sql
SELECT upper('Abc') s1 ,lower('xYz') s2
```
Чаще всего эти функции используются для унификации и стандартизации, особенно они актуальны для данных, введённых вручную.

Результат функций **upper()** и **lower()** — тоже строковый, а значит, к нему можно применять все функции, применимые к этому типу данных.

Cоставим справочник названий клиентов, у которых более десяти доставок. Данные сохраним в нижнем регистре, чтобы передавать их в другие системы (например, для обзвона), которые не чувствительны к регистру. Напишите запрос, который выводит все id названий клиентов, у которых более десяти доставок, в нижнем регистре. Отсортируйте результат по cust_id в порядке возрастания. Столбцы в выдаче: cust_id (id клиента) и cust_name (название клиента в нижнем регистре).
```sql
SELECT 
    c.cust_id,
    lower(c.cust_name) cust_name
FROM shipping.customer c
    JOIN shipping.shipment s ON c.cust_id = s.cust_id
GROUP BY 1, 2
HAVING COUNT(DISTINCT s.ship_id) > 10
ORDER BY 1
```
## REPLACE()
С помощью функции *replace()* можно заменять символы в строках.

Запись строится следующим образом:

```sql
replace(string text, from text, to text)
```

Эта запись означает, что в исходной строке string мы заменяем все вхождения строки from на строку to.
```sql
SELECT replace('малако', 'a', 'o')
```
```sql
SELECT 
    replace('машина','шина','трас')
-- Результат: матрас
```
Если вы хотите удалить из строки какие-то символы, то третьим параметром (to) передайте пустую строку ''(одинарные кавычки без символа внутри).

Например, сделаем из строки "Hello, world!" строку "Hello!".
```sql
SELECT replace('Hello, world!',', world','')
```
Составим справочник utm-меток, для того чтобы передавать город и штат прямо в адресной строке. (Если вы не знаете, что такое utm-метка, почитайте статью на Вики. К программе курса это не относится, но знать полезно.) Напишите SQL-запрос, который выведет список сочетаний из справочника следующего вида: название_штата__название_города, где названия штата и города взяты из справочника городов и переведены в нижний регистр. Столбец к выдаче — utm (форматированный штат-город). Отсортируйте полученный справочник по алфавиту. Обратите внимание! Все пробелы в названиях городов и штатов замените символом '_' (одно нижнее подчёркивание), а для разделения названий города и штата используйте '__' (два последовательных нижних подчёркивания). Пример из таблицы для наглядности: new_jersey__union_city
```sql
SELECT 
    lower(replace(c.state, ' ', '_'))||'__'|| lower(replace(c.city_name, ' ', '_')) utm
FROM shipping.city c
ORDER BY 1
```
или
```sql
SELECT 
        lower(replace(state||'__'||city_name,' ','_')) utm
FROM shipping.city
ORDER BY 1
```
## LEFT() И RIGHT()
Функции *left(string,n)* и *right(string,n)* оставляют *n* левых или правых символов от строки, поданной на вход. Давайте разобьём строку 'Один два три' на слова, используя эти функции.
```sql
with t as
(
select 'Один два три'::text sample_string
)
select 
 left(t.sample_string,4) one, /*берём 4 левых символа строки*/
 right(left(t.sample_string,8),3) two, /*берём 8 левых символов строки, потом 3 правых от результата*/
 right(t.sample_string,3) three /*берём 3 правых символа от строки*/
from t
```
Пример:
```sql
SELECT left('0123456789', -2), right('0123456789', -2)
-- Результат: 01234567 и 23456789
```
Представим, что к вам пришёл разработчик, который хочет сократить поле state в таблице city до четырёх символов, и попросил проверить, останeтся ли значения в нём уникальными. Чтобы ответить на этот вопрос, напишите SQL-запрос, который выведет первые четыре символа названия штата и количество уникальных названий штатов, которому они соответствуют. Оставьте только те, которые относятся к двум и более штатам. Добавьте сортировку по первому столбцу. Столбцы в выдаче: code (четыре первых символа в названии штата), qty (количество уникальных названий штата, начинающихся с этих символов).
```sql
SELECT 
    LEFT(c.state, 4) code,
    COUNT(DISTINCT state) qty 
FROM shipping.city c 
GROUP BY 1
HAVING COUNT(DISTINCT state) >= 2
ORDER BY 1
```
## FORMAT()
Функция format() используется для составления форматированного текста с подстановками. То же самое можно сделать через конкатенацию строк, но это неудобно и громоздко.

Допустим, у нас есть шаблон **"Hello, #Имя пользователя#!"** и таблица водителей, которым нужно вывести приветствие.

Через конкатенацию это можно сделать следующим образом:
```sql
select 'Hello, ' || d.first_name || '!' hello from shipping.driver d
```
Но если нужно подставить и имя, и фамилию, то соединений становится слишком много и сам шаблон становится трудночитаемым. Вот тут и приходит на помощь функция *format()*.

Синтаксис функции выглядит следующим образом:
```sql
format(formatstr text [, argument1 text,argument2 text...])
```
где formatstr — это шаблон, который мы передаём. Это обычная строка, в которой указаны места для подстановки аргумента.
```sql
SELECT format('Hello, %s!', d.first_name)
FROM shipping.driver d
```
Комбинация символов %s обозначает, что вместо них будет подставлен один из аргументов, причём в том же порядке, что и в исходном столбце.

```sql
SELECT format('driver_id = %s, first_name = %s, last_name = %s, address = %s, zip_code = %s, phone = %s, city_id = %s', driver_id, first_name, last_name, address, zip_code, phone, city_id)
FROM shipping.driver d
```
Мы перечислили в строке семь пропусков (плэйсхолдеров, или мест для подстановки, — %s), передали семь параметров (все столбцы таблицы) и получили шаблон, заполненный значениями для каждой строки.

Если в вашем шаблоне присутствует одинарная кавычка, то для удобства можно вместо одинарных кавычек использовать $$ (два знака доллара):
```sql
SELECT $$ some_string with quotes ' $$
-- Результат:  some_string with quotes ' 
```
Давайте подготовим географическую сводку для каждого города. Напишите SQL-запрос, который выведет описание региона в следующем формате:
```sql
[city_name] is located in [state]. There's [population] people living there. Its area is [area]
```
Обратите внимание, точку в конце ставить не нужно. Отсортируйте по названию города в алфавитном порядке. Столбец к выдаче — str (сводка). Пример:
```sql
Abilene is located in Texas. There's 115930 people living there. Its area is 105.10
```
```sql
SELECT format($$%s is located in %s. There's %s people living there. Its area is %s$$, 
        city_name, 
        state, 
        population, 
        area
    ) str
FROM shipping.city c
ORDER BY city_name
```
